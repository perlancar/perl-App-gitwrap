#!perl

# DATE
# VERSION

use 5.010001;
use strict;
use warnings;

my $Config;
my ($Cwd, $Repo_Dir, $Repo_Name);

sub read_config {
    #require PERLANCAR::File::HomeDir;

    for my $dir ("$ENV{HOME}/.config", $ENV{HOME}, "/etc") {
        my $file = "$dir/gitwrap.conf";
        if (-f $file) {
            require Config::IOD::Reader;
            $Config = Config::IOD::Reader->new->read_file($file);
            return;
        }
    }
    $Config = {};
}

sub run_cmd_template {
    require Cwd;

    my ($cmdt) = @_;

    unless ($Cwd) {
        $Cwd = Cwd::getcwd();

      FIND_REPO_TOP_LEVEL_DIR:
        {
            my $cwd = $Cwd;
            while (1) {
                if (-d ".git") {
                    $Repo_Dir = $cwd;
                    ($Repo_Name = $Repo_Dir) =~ s!.+/!!;
                    last;
                }
                chdir ".." or last;
                $cwd =~ s!(.+)/.+!$1! or last;
            }
        }
    }

    my %tvars;
    my %env;
    $tvars{REPO_NAME} = $Repo_Name;
    $env{GIT_REPO_NAME} = $Repo_Name;

    my $cmd = $cmdt;
    $cmd =~ s/%\{(\w+)\}/defined($tvars{$1}) ? $tvars{$1} : "%{$1}"/eg;

    chdir $Repo_Dir if defined($Repo_Dir);
    say "D2:cmd=<$cmd>";
    system $cmd;
    chdir $Cwd if defined($Repo_Dir);
}

sub do_stuffs {
    if ($Config->{GLOBAL}{before_commit_cmdt} && @ARGV && $ARGV[0] eq 'commit') {
        run_cmd_template($Config->{GLOBAL}{before_commit_cmdt});
    }
    if ($Config->{GLOBAL}{before_status_cmdt} && @ARGV && $ARGV[0] eq 'status') {
        run_cmd_template($Config->{GLOBAL}{before_status_cmdt});
    }
}


sub exec_git {
    my @cmd = ($Config->{GLOBAL}{git_path} // 'git', @ARGV);
    exec {$cmd[0]} @cmd;
}

### main

read_config;
do_stuffs;
exec_git;

# ABSTRACT: Git wrapper script
# PODNAME:

=head1 SYNOPSIS

Use like you would C<git>:

 % gitwrap commit -m ...
 ...

To use the name C<git>, in your Unix shell:

 alias git=gitwrap

then this will call C<gitwrap> instead.

 % git commit -m ...
 ...


=head1 DESCRIPTION

C<gitwrap> is a script that will eventually exec() the C<git> binary. But before
it does that, it can do some things first.

It will first search for configuration file F<gitwrap.conf> in one of these
locations: F<~/.config>, F<~>, or F</etc>. See L</"CONFIGURATION">.

It will then use the git binary as specified in the configuration C<git_path> or
just use C<git>.

Some examples of how I use this script:

=over

=item * Fixing user and email before commit

Doing this in C<pre-commit> hook is too late as C<git> already decides the
user/email, so if you use C<pre-commit> hook for this the best you can do is fix
user/email then exit non-zero so the commit is aborted. Then you commit again.

With this wrapper, this extra step is unnecessary.

=item * Touching last commit/status timestamp

I updated a record in a database whenever a repository is committed into or
status-ed. The first can be done with a C<post-commit> hook, but for the second
there is no hook provided by git. I do this to speed up or prioritize
repositories that are more recently modified/accessed in L<Git::Bunch>: When
there are hundreds/thousand+ git repositories in a gitbunch, and only a few of
them need to be synchronized, using these timestamps can dramatically shorten
the amount of time to determine which repositories need to be included, because
we avoid having to 'git status' every single repository.

=back


=head1 CONFIGURATION

=head2 git_path

=head2 before_commit_cmd_template

=head2 before_status_cmd_template


=head1 SEE ALSO

C<git>
